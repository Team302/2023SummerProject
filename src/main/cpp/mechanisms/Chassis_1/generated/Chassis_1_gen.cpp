// clang-format off
//====================================================================================================================================================
// Copyright 2023 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 1.1.0.0
// Generated on Saturday, January 6, 2024 8:30:58 AM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include "hw/interfaces/IDragonMotorController.h"

#include "Chassis_1_gen.h"

#include "hw/DragonTalonSRX.h"
#include "hw/DragonTalonSRX.h"

#include "mechanisms/Chassis_1/decoratormods/Chassis_1_leftRearWheel_State.h"
#include "mechanisms/Chassis_1/decoratormods/Chassis_1_RightRearWheel_State.h"
#include "mechanisms/Chassis_1/decoratormods/Chassis_1_LeftFrontWheel_State.h"
#include "mechanisms/Chassis_1/decoratormods/Chassis_1_RightFrontWheel_State.h"

Chassis_1_gen::Chassis_1_gen() : Thing1Chassis ( MechanismTypes::MECHANISM_TYPE::CHASSIS_1, std::string ( "Chassis_1" ) ),
	m_motorMap(),
	m_solenoidMap(),
	m_servoMap()
{
}

void Chassis_1_gen::Create()
{
	m_ntName = "Chassis_1";

	DistanceAngleCalcStruc TalonSRX_LeftRearCalcStruct;
	TalonSRX_LeftRearCalcStruct.countsPerRev = 10 ;
	TalonSRX_LeftRearCalcStruct.gearRatio = 11 ;
	TalonSRX_LeftRearCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 0.1 ) ).to<double>() ;
	TalonSRX_LeftRearCalcStruct.countsPerInch = 5 ;
	TalonSRX_LeftRearCalcStruct.countsPerDegree = 4 ;
	TalonSRX_LeftRear = new DragonTalonSRX ( "TalonSRX_LeftRear",RobotElementNames::MOTOR_CONTROLLER_USAGE::THING1CHASSIS_TALONSRX_LEFTREAR,0,0,TalonSRX_LeftRearCalcStruct, IDragonMotorController::MOTOR_TYPE::ANDYMARKNEVEREST );
	m_motorMap[TalonSRX_LeftRear->GetType()] = new BaseMechMotor ( m_ntName, *TalonSRX_LeftRear, BaseMechMotor::EndOfTravelSensorOption::NONE, nullptr, BaseMechMotor::EndOfTravelSensorOption::NONE, nullptr );

	DistanceAngleCalcStruc TalonSRX_RightRearCalcStruct;
	TalonSRX_RightRearCalcStruct.countsPerRev = 0 ;
	TalonSRX_RightRearCalcStruct.gearRatio = 1 ;
	TalonSRX_RightRearCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	TalonSRX_RightRearCalcStruct.countsPerInch = 0 ;
	TalonSRX_RightRearCalcStruct.countsPerDegree = 2 ;
	TalonSRX_RightRear = new DragonTalonSRX ( "TalonSRX_RightRear",RobotElementNames::MOTOR_CONTROLLER_USAGE::THING1CHASSIS_TALONSRX_RIGHTREAR,1,0,TalonSRX_RightRearCalcStruct, IDragonMotorController::MOTOR_TYPE::ANDYMARKNEVEREST );
	m_motorMap[TalonSRX_RightRear->GetType()] = new BaseMechMotor ( m_ntName, *TalonSRX_RightRear, BaseMechMotor::EndOfTravelSensorOption::NONE, nullptr, BaseMechMotor::EndOfTravelSensorOption::NONE, nullptr );

	Chassis_1leftRearWheelState* leftRearWheelState = new Chassis_1leftRearWheelState ( string ( "leftRearWheel" ), 0, new Chassis_1leftRearWheelStateGen ( string ( "leftRearWheel" ), 0, *this ) );
	AddToStateVector ( leftRearWheelState );

	Chassis_1RightRearWheelState* RightRearWheelState = new Chassis_1RightRearWheelState ( string ( "RightRearWheel" ), 1, new Chassis_1RightRearWheelStateGen ( string ( "RightRearWheel" ), 1, *this ) );
	AddToStateVector ( RightRearWheelState );

	Chassis_1LeftFrontWheelState* LeftFrontWheelState = new Chassis_1LeftFrontWheelState ( string ( "LeftFrontWheel" ), 2, new Chassis_1LeftFrontWheelStateGen ( string ( "LeftFrontWheel" ), 2, *this ) );
	AddToStateVector ( LeftFrontWheelState );

	Chassis_1RightFrontWheelState* RightFrontWheelState = new Chassis_1RightFrontWheelState ( string ( "RightFrontWheel" ), 3, new Chassis_1RightFrontWheelStateGen ( string ( "RightFrontWheel" ), 3, *this ) );
	AddToStateVector ( RightFrontWheelState );

	leftRearWheelState->RegisterTransitionState ( RightRearWheelState );
	RightRearWheelState->RegisterTransitionState ( LeftFrontWheelState );
	LeftFrontWheelState->RegisterTransitionState ( RightFrontWheelState );
	RightFrontWheelState->RegisterTransitionState ( leftRearWheelState );

	m_table = nt::NetworkTableInstance::GetDefault().GetTable ( m_ntName );
	m_tuningIsEnabledStr = "Enable Tuning for " + m_ntName; // since this string is used every loop, we do not want to create the string every time
	m_table.get()->PutBoolean ( m_tuningIsEnabledStr, m_tuning );
}

void Chassis_1_gen::Initialize ( RobotConfigMgr::RobotIdentifier robotFullName )
{
	if ( false ) {}
	else if ( RobotConfigMgr::RobotIdentifier::CompBot_1 == robotFullName )
	{

//todo create initialization for leftRearWheel
//todo create initialization for RightRearWheel
//todo create initialization for LeftFrontWheel
//todo create initialization for RightFrontWheel
	}

}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void Chassis_1_gen::SetControlConstants ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->SetControlConstants ( slot, pid );
	}
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void Chassis_1_gen::Update()
{
	for ( auto motor : m_motorMap )
	{
		motor.second->Update();
	}
}

void Chassis_1_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, double percentOutput )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( percentOutput );
	}
}

void Chassis_1_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::angle::degree_t angle )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( angle );
	}
}

void Chassis_1_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::angular_velocity::revolutions_per_minute_t angVel )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( angVel );
	}
}
void Chassis_1_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::length::inch_t position )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( position );
	}
}
void Chassis_1_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::velocity::feet_per_second_t velocity )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( velocity );
	}
}
void Chassis_1_gen::UpdateTarget ( RobotElementNames::SOLENOID_USAGE identifier, bool extend )
{
	auto sol = GetSolenoidMech ( identifier );
	if ( sol != nullptr )
	{
		sol->ActivateSolenoid ( extend );
	}
}

bool Chassis_1_gen::IsAtMinPosition ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier ) const
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		return motor->IsAtMinTravel();
	}
	return false;
}
bool Chassis_1_gen::IsAtMinPosition ( RobotElementNames::SOLENOID_USAGE identifier ) const
{
	auto sol = GetSolenoidMech ( identifier );
	if ( sol != nullptr )
	{
		return !sol->IsSolenoidActivated();
	}
	return false;
}
bool Chassis_1_gen::IsAtMaxPosition ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier ) const
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		return motor->IsAtMaxTravel();
	}
	return false;
}
bool Chassis_1_gen::IsAtMaxPosition ( RobotElementNames::SOLENOID_USAGE identifier ) const
{
	auto sol = GetSolenoidMech ( identifier );
	if ( sol != nullptr )
	{
		return sol->IsSolenoidActivated();
	}
	return false;
}

BaseMechMotor *Chassis_1_gen::GetMotorMech ( RobotElementNames::MOTOR_CONTROLLER_USAGE usage ) const
{
	auto itr = m_motorMap.find ( usage );
	if ( itr != m_motorMap.end() )
	{
		return itr->second;
	}
	return nullptr;
}

std::vector<RobotElementNames::MOTOR_CONTROLLER_USAGE> Chassis_1_gen::GetMotorUsages() const
{
	std::vector<RobotElementNames::MOTOR_CONTROLLER_USAGE> output;
	for ( auto itr = m_motorMap.begin(); itr != m_motorMap.end(); ++itr )
	{
		output.emplace_back ( itr->first );
	}
	return output;
}

BaseMechSolenoid *Chassis_1_gen::GetSolenoidMech ( RobotElementNames::SOLENOID_USAGE usage ) const
{
	auto itr = m_solenoidMap.find ( usage );
	if ( itr != m_solenoidMap.end() )
	{
		return itr->second;
	}
	return nullptr;
}

std::vector<RobotElementNames::SOLENOID_USAGE> Chassis_1_gen::GetSolenoidUsages() const
{
	std::vector<RobotElementNames::SOLENOID_USAGE> output;
	for ( auto itr = m_solenoidMap.begin(); itr != m_solenoidMap.end(); ++itr )
	{
		output.emplace_back ( itr->first );
	}
	return output;
}

BaseMechServo *Chassis_1_gen::GetServoMech ( RobotElementNames::SERVO_USAGE usage ) const
{
	auto itr = m_servoMap.find ( usage );
	if ( itr != m_servoMap.end() )
	{
		return itr->second;
	}
	return nullptr;
}

std::vector<RobotElementNames::SERVO_USAGE> Chassis_1_gen::GetServoUsages() const
{
	std::vector<RobotElementNames::SERVO_USAGE> output;
	for ( auto itr = m_servoMap.begin(); itr != m_servoMap.end(); ++itr )
	{
		output.emplace_back ( itr->first );
	}
	return output;
}