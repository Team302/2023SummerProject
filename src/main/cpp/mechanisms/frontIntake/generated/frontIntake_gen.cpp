// clang-format off
//====================================================================================================================================================
// Copyright 2023 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 1.1.0.0
// Generated on Monday, December 18, 2023 7:31:23 PM

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include "hw/interfaces/IDragonMotorController.h"

#include "frontIntake_gen.h"

using ctre::phoenixpro::signals::ForwardLimitSourceValue;
using ctre::phoenixpro::signals::ForwardLimitTypeValue;
using ctre::phoenixpro::signals::ReverseLimitSourceValue;
using ctre::phoenixpro::signals::ReverseLimitTypeValue;
using ctre::phoenixpro::signals::InvertedValue;
using ctre::phoenixpro::signals::NeutralModeValue;
using ctre::phoenix::motorcontrol::RemoteSensorSource;

frontIntake_gen::frontIntake_gen()
{
}

void frontIntake_gen::Initialize ( RobotConfigMgr::RobotIdentifier robotFullName )
{
	m_ntName = "frontIntake";
	mainWheel = new DragonTalonFX ( "mainWheel",RobotElementNames::MOTOR_CONTROLLER_USAGE::INTAKE_MECHANISM_MAIN_WHEEL,9,"rio" );
	pushSolenoid = new DragonSolenoid ( "pushSolenoid",RobotElementNames::SOLENOID_USAGE::INTAKE_MECHANISM_PUSH_SOLENOID,1,frc::PneumaticsModuleType::CTREPCM,5,false );

	m_table = nt::NetworkTableInstance::GetDefault().GetTable ( m_ntName );
	m_table.get()->PutBoolean ( "Enable Tuning for frontIntake?", m_tuning );

	if ( false ) {}
	else if ( RobotConfigMgr::RobotIdentifier::CompBot_1 == robotFullName )
	{
		mainWheel->SetCurrentLimits ( false,
		                              units::current::ampere_t ( 0 ),
		                              false,
		                              units::current::ampere_t ( 0 ),
		                              units::current::ampere_t ( 0 ),
		                              units::time::second_t ( 0 ) );
		mainWheel->ConfigHWLimitSW ( false, // enableForward
		                             0, // remoteForwardSensorID
		                             false, // forwardResetPosition
		                             0, // forwardPosition
		                             ForwardLimitSourceValue::LimitSwitchPin, // forwardType
		                             ForwardLimitTypeValue::NormallyOpen, // forwardOpenClose
		                             false, // enableReverse
		                             0, // remoteReverseSensorID
		                             false, // reverseResetPosition
		                             0, // reversePosition
		                             ReverseLimitSourceValue::LimitSwitchPin, // revType
		                             ReverseLimitTypeValue::NormallyOpen ); // revOpenClose
		mainWheel->ConfigMotorSettings ( InvertedValue::CounterClockwise_Positive, // ctre::phoenixpro::signals::InvertedValue
		                                 NeutralModeValue::Coast, // ctre::phoenixpro::signals::NeutralModeValue
		                                 0, // deadbandPercent
		                                 0, // peakForwardDutyCycle
		                                 0 ); // peakReverseDutyCycle
		mainWheel->SetAsFollowerMotor ( 0 ); // masterCANID
		mainWheel->SetRemoteSensor ( 0, // canID
		                             RemoteSensorSource::RemoteSensorSource_Off ); // ctre::phoenix::motorcontrol::RemoteSensorSource
		mainWheel->SetDiameter ( 0 ); // double diameter
// pushSolenoid : Solenoids do not have initialization needs
	}
	else if ( RobotConfigMgr::RobotIdentifier::PracticeBot_9900 == robotFullName )
	{
		mainWheel->SetCurrentLimits ( false,
		                              units::current::ampere_t ( 0 ),
		                              false,
		                              units::current::ampere_t ( 0 ),
		                              units::current::ampere_t ( 0 ),
		                              units::time::second_t ( 0 ) );
		mainWheel->ConfigHWLimitSW ( false, // enableForward
		                             0, // remoteForwardSensorID
		                             false, // forwardResetPosition
		                             0, // forwardPosition
		                             ForwardLimitSourceValue::LimitSwitchPin, // forwardType
		                             ForwardLimitTypeValue::NormallyOpen, // forwardOpenClose
		                             false, // enableReverse
		                             0, // remoteReverseSensorID
		                             false, // reverseResetPosition
		                             0, // reversePosition
		                             ReverseLimitSourceValue::LimitSwitchPin, // revType
		                             ReverseLimitTypeValue::NormallyOpen ); // revOpenClose
		mainWheel->ConfigMotorSettings ( InvertedValue::CounterClockwise_Positive, // ctre::phoenixpro::signals::InvertedValue
		                                 NeutralModeValue::Coast, // ctre::phoenixpro::signals::NeutralModeValue
		                                 0, // deadbandPercent
		                                 0, // peakForwardDutyCycle
		                                 0 ); // peakReverseDutyCycle
		mainWheel->SetAsFollowerMotor ( 0 ); // masterCANID
		mainWheel->SetRemoteSensor ( 0, // canID
		                             RemoteSensorSource::RemoteSensorSource_Off ); // ctre::phoenix::motorcontrol::RemoteSensorSource
		mainWheel->SetDiameter ( 0 ); // double diameter
// pushSolenoid : Solenoids do not have initialization needs
	}

}