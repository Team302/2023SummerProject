<?xml version="1.0"?>
<toolConfiguration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">

<rootOutputFolder>..\..\src\main\cpp</rootOutputFolder>
<robotConfiguration>..\..\src\main\deploy\practiceBot.xml</robotConfiguration>

<robotConfigurations>
	<string>..\..\src\main\deploy\practiceBot.xml</string>
	<string>..\..\src\main\deploy\robot.xml</string>
</robotConfigurations>

<treeviewParentNameExtensions>
	<string>usage</string>
	<string>type</string>
	<string>stateIdentifier</string>
	<string>identifier</string>
</treeviewParentNameExtensions>

<GenerationNotice>
//==============================================================
// This file is auto generated by FRCrobotCodeGen302.exe Version $CODE_GENERATOR_VERSION$ 
// Changes to this file may cause incorrect behavior and will be lost when 
// the code is regenerated, unless the changes are delimited by:
//  //========= Hand modified code start section x ======== 
//                    Your hand written code goes here
//	//========= Hand modified code end section x ========
//==============================================================
</GenerationNotice>

<CopyrightNotice>
//====================================================================================================================================================
// Copyright 2023 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================

</CopyrightNotice>

<RobotConfig_h>

#pragma once

#define $CHASSIS_TYPE_CONFIG$


</RobotConfig_h>

<AllMechanisms_h>

#pragma once

$INCLUDES_FOR_ALL_MECHANISMS$

</AllMechanisms_h>

<AllMechanismsState_h>

#pragma once

$INCLUDES_FOR_ALL_MECHANISMS$

</AllMechanismsState_h>

<AllMechanismsStateMgr_h>

#pragma once

$INCLUDES_FOR_ALL_MECHANISMS$

</AllMechanismsStateMgr_h>

<MechanismTypes_h>

#pragma once

#include &lt;map&gt;
#include &lt;string&gt;

//========================================================================================================
///	 @class			MechanismTypes
///  @brief      	This contains the enum for the mechanism types
//========================================================================================================
class MechanismTypes
{
	public:

        //==================================================================================
        /// enum:           MECHANISM_TYPE
        /// description:    Indicates the type of mechanism
        //==================================================================================
        enum MECHANISM_TYPE
        {
            UNKNOWN_MECHANISM = -1,
            $COMMA_SEPARATED_MECHANISM_NAMES$
        

            MAX_MECHANISM_TYPES
        };

        static MechanismTypes* GetInstance();

        MECHANISM_TYPE GetType
        ( 
            std::string         typeString
        );


    private:
        static MechanismTypes*    m_instance;
        MechanismTypes();
        ~MechanismTypes();
        
		std::map &lt;std::string, MECHANISM_TYPE&gt; m_typeMap;

};


</MechanismTypes_h>

<MechanismTypes_cpp>

// C++ Includes
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

// FRC includes

// Team 302 includes
#include &lt;mechanisms/MechanismTypes.h&gt;
#include &lt;utils/logging/Logger.h&gt;

// @ADDMECH add your mechanism include 


// Third Party Includes

using namespace std;

MechanismTypes* MechanismTypes::m_instance = nullptr;
MechanismTypes* MechanismTypes::GetInstance()
{
    if ( m_instance == nullptr )
    {
        m_instance = new MechanismTypes();
    }
    return m_instance;
}

MechanismTypes::MechanismTypes()
{
    $MECHANISM_NAMES_MAPPED_TO_ENUMS$ 
    //m_typeMap["EXAMPLE"]    = MECHANISM_TYPE::EXAMPLE;
}

MechanismTypes::~MechanismTypes()
{
    m_typeMap.clear();
}

MechanismTypes::MECHANISM_TYPE MechanismTypes::GetType
(
    string              typeString
)
{
    auto it = m_typeMap.find(typeString);
    if (it != m_typeMap.end())
    {
        return it->second;
    }
    Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, string("MechanismTypes"), string("GetType - unknown mechanism type"), typeString);
    return MechanismTypes::MECHANISM_TYPE::UNKNOWN_MECHANISM;
}

</MechanismTypes_cpp>

<Usage_h>
		
		#pragma once

		// C++ Includes
		#include &lt;map&gt;
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes

					// Third Party Includes



					class $ITEM_USAGE_CLASS_NAME$
					{

					public:

					/// @enum MOTOR_CONTROLLER_USAGE
					/// @brief Defines $ITEM_CLASS_NAME_PREFIX$ usages.  This should be modified for each robot.
					enum $ITEM_NAME_UPPERCASE$_USAGE
					{
					UNKNOWN_$ITEM_NAME_UPPERCASE$_USAGE = -1,
					
					$USAGE_ENUM_COMMA_SEPARATED$

					MAX_$ITEM_NAME_UPPERCASE$_USAGES
					};

					static $ITEM_USAGE_CLASS_NAME$* GetInstance();

					$ITEM_NAME_UPPERCASE$_USAGE GetUsage
					(
					std::string         usageString
					);


					private:
					static $ITEM_USAGE_CLASS_NAME$*    m_instance;
					$ITEM_USAGE_CLASS_NAME$();
					~$ITEM_USAGE_CLASS_NAME$();

					std::map &lt;std::string, $ITEM_NAME_UPPERCASE$_USAGE&gt; m_usageMap;

};
</Usage_h>
<Usage_cpp>
		
		// C++ Includes
		#include &lt;map&gt;
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes
					#include &lt;hw/usages/$ITEM_USAGE_CLASS_NAME$.h&gt;
					#include &lt;utils/logging/Logger.h&gt;

					// Third Party Includes

					using namespace std;

					$ITEM_USAGE_CLASS_NAME$* $ITEM_USAGE_CLASS_NAME$::m_instance = nullptr;
					$ITEM_USAGE_CLASS_NAME$* $ITEM_USAGE_CLASS_NAME$::GetInstance()
					{
					if ( m_instance == nullptr )
					{
					m_instance = new $ITEM_USAGE_CLASS_NAME$();
					}
					return m_instance;
					}

					$ITEM_USAGE_CLASS_NAME$::$ITEM_USAGE_CLASS_NAME$()
					{

					$USAGE_TEXT_TO_ENUM_MAP$

					}

					$ITEM_USAGE_CLASS_NAME$::~$ITEM_USAGE_CLASS_NAME$()
					{
					m_usageMap.clear();
					}

					$ITEM_USAGE_CLASS_NAME$::$ITEM_NAME_UPPERCASE$_USAGE $ITEM_USAGE_CLASS_NAME$::GetUsage
					(
					string              usageString
					)
					{
					auto it = m_usageMap.find(usageString);
					if (it != m_usageMap.end())
					{
					return it->second;
					}
					Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, string("$ITEM_USAGE_CLASS_NAME$::GetUsage"), string("unknown usage"), usageString);
					return $ITEM_USAGE_CLASS_NAME$::$ITEM_NAME_UPPERCASE$_USAGE::UNKNOWN_$ITEM_NAME_UPPERCASE$_USAGE;
					}

</Usage_cpp>

	<ServoUsage_h>

		#pragma once

		// C++ Includes
		#include &lt;map&gt;
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes


					// Third Party Includes



					class ServoUsage
					{

					public:

					/// @enum SERVO_USAGE
					/// @brief Defines Servo usages.  This should be modified for each robot.
					enum SERVO_USAGE
					{
					UNKNOWN_SERVO_USAGE = -1,

					$USAGE_ENUM_COMMA_SEPARATED$

					MAX_SERVO_USAGES
					};


					static ServoUsage* GetInstance();

					SERVO_USAGE GetUsage
					(
					const std::string         usageString
					);

					private:
					static ServoUsage*    m_instance;
					ServoUsage();
					~ServoUsage();

					std::map &lt;std::string, SERVO_USAGE&gt; m_usageMap;

};




	</ServoUsage_h>
	
	<ServoUsage_cpp>

		// C++ Includes
		#include &lt;map&gt;
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes
					#include &lt;hw/usages/ServoUsage.h&gt;
					#include &lt;utils/logging/Logger.h&gt;

					// Third Party Includes

					using namespace std;

					ServoUsage* ServoUsage::m_instance = nullptr;
					ServoUsage* ServoUsage::GetInstance()
					{
					if ( m_instance == nullptr )
					{
					m_instance = new ServoUsage();
					}
					return m_instance;
					}

					ServoUsage::ServoUsage()
					{
						$USAGE_TEXT_TO_ENUM_MAP$

					}

					ServoUsage::~ServoUsage()
					{
					m_usageMap.clear();
					}

					ServoUsage::SERVO_USAGE ServoUsage::GetUsage
					(
					const string              usageString
					)
					{
					auto it = m_usageMap.find(usageString);
					if (it != m_usageMap.end())
					{
					return it->second;
					}
					Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, string("ServoUsage::GetUsage"), string("unknown usage"), usageString);
					return ServoUsage::SERVO_USAGE::UNKNOWN_SERVO_USAGE;
					}


				</ServoUsage_cpp>

	<DigitalInputUsage_h>

		#pragma once

		// C++ Includes
		#include &lt;map&gt;
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes


					// Third Party Includes

					class DigitalInputUsage
					{

					public:

					/// @enum DIGITAL_INPUT_USAGE
					/// @brief Defines digital input sensor usages.  This should be modified for each robot.
					enum DIGITAL_INPUT_USAGE
					{
					UNKNOWN_DIGITAL_INPUT_USAGE = -1,

					$USAGE_ENUM_COMMA_SEPARATED$
					
					MAX_DIGITAL_INPUT_USAGE
					};

					static DigitalInputUsage* GetInstance();

					DIGITAL_INPUT_USAGE GetUsage
					(
					std::string         usageString
					);

					private:
					static DigitalInputUsage*    m_instance;
					DigitalInputUsage();
					~DigitalInputUsage();

					std::map &lt;std::string, DIGITAL_INPUT_USAGE&gt; m_usageMap;

};

	</DigitalInputUsage_h>

	<DigitalInputUsage_cpp>


		// C++ Includes
		#include &lt;map&gt;
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes
					#include &lt;hw/usages/DigitalInputUsage.h&gt;
					#include &lt;utils/logging/Logger.h&gt;

					// Third Party Includes

					using namespace std;

					DigitalInputUsage* DigitalInputUsage::m_instance = nullptr;
					DigitalInputUsage* DigitalInputUsage::GetInstance()
					{
					if ( m_instance == nullptr )
					{
					m_instance = new DigitalInputUsage();
					}
					return m_instance;
					}

					DigitalInputUsage::DigitalInputUsage()
					{
						$USAGE_TEXT_TO_ENUM_MAP$

					}

					DigitalInputUsage::~DigitalInputUsage()
					{
					m_usageMap.clear();
					}

					DigitalInputUsage::DIGITAL_INPUT_USAGE DigitalInputUsage::GetUsage
					(
					string              usageString
					)
					{
					auto it = m_usageMap.find(usageString);
					if (it != m_usageMap.end())
					{
					return it->second;
					}
					Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, string("DigitalInputUsage::GetUsage"), string("unknown usage"), usageString);
					return DigitalInputUsage::DIGITAL_INPUT_USAGE::UNKNOWN_DIGITAL_INPUT_USAGE;
					}


				</DigitalInputUsage_cpp>

	<MotorControllerUsage_h>
		
		#pragma once

		// C++ Includes
		#include &lt;map&gt;
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes

					// Third Party Includes



					class MotorControllerUsage
					{

					public:

					/// @enum MOTOR_CONTROLLER_USAGE
					/// @brief Defines motor usages.  This should be modified for each robot.
					enum MOTOR_CONTROLLER_USAGE
					{
					UNKNOWN_MOTOR_CONTROLLER_USAGE = -1,
					
					$USAGE_ENUM_COMMA_SEPARATED$

					MAX_MOTOR_CONTROLLER_USAGES
					};

					static MotorControllerUsage* GetInstance();

					MOTOR_CONTROLLER_USAGE GetUsage
					(
					std::string         usageString
					);


					private:
					static MotorControllerUsage*    m_instance;
					MotorControllerUsage();
					~MotorControllerUsage();

					std::map &lt;std::string, MOTOR_CONTROLLER_USAGE&gt; m_usageMap;

};




	</MotorControllerUsage_h>

	<MotorControllerUsage_cpp>

		// C++ Includes
		#include &lt;map&gt;
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes
					#include &lt;hw/usages/MotorControllerUsage.h&gt;
					#include &lt;utils/logging/Logger.h&gt;

					// Third Party Includes

					using namespace std;

					MotorControllerUsage* MotorControllerUsage::m_instance = nullptr;
					MotorControllerUsage* MotorControllerUsage::GetInstance()
					{
					if ( m_instance == nullptr )
					{
					m_instance = new MotorControllerUsage();
					}
					return m_instance;
					}

					MotorControllerUsage::MotorControllerUsage()
					{

					$USAGE_TEXT_TO_ENUM_MAP$

					}

					MotorControllerUsage::~MotorControllerUsage()
					{
					m_usageMap.clear();
					}

					MotorControllerUsage::MOTOR_CONTROLLER_USAGE MotorControllerUsage::GetUsage
					(
					string              usageString
					)
					{
					auto it = m_usageMap.find(usageString);
					if (it != m_usageMap.end())
					{
					return it->second;
					}
					Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, string("MotorControllerUsage::GetUsage"), string("unknown usage"), usageString);
					return MotorControllerUsage::MOTOR_CONTROLLER_USAGE::UNKNOWN_MOTOR_CONTROLLER_USAGE;
					}

				</MotorControllerUsage_cpp>

	<SolenoidUsage_h>

		#pragma once

		// C++ Includes
		#include &lt;map&gt;
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes


					// Third Party Includes



					class SolenoidUsage
					{

					public:

					/// @enum SOLENOID_USAGE
					/// @brief Defines solenoid usages.  This should be modified for each robot.
					enum SOLENOID_USAGE
					{
					UNKNOWN_SOLENOID_USAGE = -1,

					$USAGE_ENUM_COMMA_SEPARATED$

					MAX_SOLENOID_USAGES
					};


					static SolenoidUsage* GetInstance();

					SOLENOID_USAGE GetUsage
					(
					const std::string         usageString
					);

					private:
					static SolenoidUsage*    m_instance;
					SolenoidUsage();
					~SolenoidUsage();

					std::map &lt;std::string, SOLENOID_USAGE&gt; m_usageMap;

};




	</SolenoidUsage_h>

	<SolenoidUsage_cpp>

		// C++ Includes
		#include &lt;map>
			#include &lt;memory&gt;
				#include &lt;string&gt;

					// FRC includes

					// Team 302 includes
					#include &lt;hw/usages/SolenoidUsage.h&gt;
					#include &lt;utils/logging/Logger.h&gt;

					// Third Party Includes

					using namespace std;

					SolenoidUsage* SolenoidUsage::m_instance = nullptr;
					SolenoidUsage* SolenoidUsage::GetInstance()
					{
					if ( m_instance == nullptr )
					{
					m_instance = new SolenoidUsage();
					}
					return m_instance;
					}

					SolenoidUsage::SolenoidUsage()
					{

					$USAGE_TEXT_TO_ENUM_MAP$

					}

					SolenoidUsage::~SolenoidUsage()
					{
					m_usageMap.clear();
					}

					SolenoidUsage::SOLENOID_USAGE SolenoidUsage::GetUsage
					(
					const string              usageString
					)
					{
					auto it = m_usageMap.find(usageString);
					if (it != m_usageMap.end())
					{
					return it->second;
					}
					Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, string("Solenoid::GetUsage"), string("unknown usage"), usageString);
					return SolenoidUsage::SOLENOID_USAGE::UNKNOWN_SOLENOID_USAGE;
					}


				</SolenoidUsage_cpp>
	
	<main_h>
		
		#pragma once

		// C++ Includes
		#include &lt;memory&gt;
			#include &lt;string&gt;

				// Team 302 includes
				#include &lt;mechanisms/base/$MECH_BASE_CLASS$.h&gt;

		class $MECHANISM_NAME$ : public $MECH_BASE_CLASS$
		{
		public:
		/// @brief Create an $MECHANISM_NAME$ mechanism wiht 1 independent motor
		/// @param [in] std::string the name of the file that will set control parameters for this mechanism
		/// @param [in] std::string the name of the network table for logging information
		/// @param [in] std::shared_ptr&lt;IDragonMotorController&gt;
		
		$MECHANISM_NAME$
		(
		std::string                                 controlFileName,
		std::string                                 networkTableName
		$MECHANISM_CONSTRUCTOR_PARAMETER_LIST$
		);
		$MECHANISM_NAME$() = delete;
		~$MECHANISM_NAME$() override = default;

			//========= Hand modified code start section 0 ========
	
			//========= Hand modified code end section 0 ========
		};
	</main_h>

	<main_cpp>
		
		// C++ Includes
		#include &lt;memory&gt;
			#include &lt;string&gt;

				//team 302 includes
				#include &lt;hw/interfaces/IDragonMotorController.h&gt;
				#include &lt;mechanisms/base/$MECH_BASE_CLASS$.h&gt;
				#include &lt;mechanisms/$MECHANISM_NAME_LOWERCASE$/$MECHANISM_NAME_LOWERCASE$.h&gt;

				// Third Party Includes
	//========= Hand modified code start section 1 ========
	
	//========= Hand modified code end section 1 ========
				
		using namespace std;

		/// @brief Create an $MECHANISM_NAME$ mechanism wiht 1 independent motor
		/// @param [in] std::string the name of the file that will set control parameters for this mechanism
		/// @param [in] std::string the name of the network table for logging information
		/// @param [in] std::shared_ptr&lt;IDragonMotorController&gt;
		
		$MECHANISM_NAME$::$MECHANISM_NAME$
		(
		std::string                                 controlFileName,
		std::string                                 networkTableName
		$MECHANISM_CONSTRUCTOR_PARAMETER_LIST$
		):$MECH_BASE_CLASS$(MechanismTypes::MECHANISM_TYPE::$MECHANISM_NAME_UPPERCASE$,controlFileName,networkTableName $MECHANISM_CONSTRUCTOR_ARGUMENT_LIST$)
		{
		}

	//========= Hand modified code start section 0 ========
	
	//========= Hand modified code end section 0 ========
	</main_cpp>
	
	<state_cpp>

		// C++ Includes
		#include  &lt;string&gt;

		// FRC includes

		// Team 302 includes
		#include  &lt;mechanisms/base/$MECH_BASE_CLASS$State.h&gt;
		#include  &lt;mechanisms/controllers/ControlData.h&gt;
		#include  &lt;mechanisms/$MECHANISM_NAME_LOWERCASE$/$MECHANISM_NAME$State.h&gt;
		#include  &lt;mechanisms/MechanismFactory.h&gt;

		// Third Party Includes

		using namespace std;

		$MECHANISM_NAME$State::$MECHANISM_NAME$State
		(
		string                          stateName,
		int                             stateId
		$MECHANISM_CONSTRUCTOR_PARAMETER_LIST$
		) : $MECH_BASE_CLASS$State( MechanismFactory::GetMechanismFactory()->Get$MECHANISM_NAME$(), stateName, stateId $MECHANISM_CONSTRUCTOR_ARGUMENT_LIST$),
		m_$MECHANISM_NAME_LOWERCASE$(MechanismFactory::GetMechanismFactory()->Get$MECHANISM_NAME$())
		{

		}

		bool $MECHANISM_NAME$State::AtTarget() const
		{
				//========= Hand modified code start section 0 ========
				//========= Hand modified code end section 0 ========
		return true;
		}


	</state_cpp>
	<state_h>
		
		#pragma once
		#include &lt;string&gt;

			#include &lt;mechanisms/base/$MECH_BASE_CLASS$State.h&gt;

		class ControlData;
		class $MECHANISM_NAME$;

		class $MECHANISM_NAME$State : public $MECH_BASE_CLASS$State
		{
		public:

		$MECHANISM_NAME$State() = delete;
		$MECHANISM_NAME$State
		(
		std::string                     stateName,
		int                             stateId
		$MECHANISM_CONSTRUCTOR_PARAMETER_LIST$
		);
		~$MECHANISM_NAME$State() = default;


		bool AtTarget() const override;
		$MECHANISM_NAME$ * Get$MECHANISM_NAME$() const {return m_$MECHANISM_NAME_LOWERCASE$;}

		private:
		$MECHANISM_NAME$*        m_$MECHANISM_NAME_LOWERCASE$;
		};
	</state_h>
  <stateManager_h>

#pragma once

// C++ Includes
#include &lt;string&gt;

// FRC includes

// Team 302 includes
#include &lt;mechanisms/base/StateMgr.h&gt;
#include &lt;mechanisms/$MECHANISM_NAME$/$MECHANISM_NAME_LOWERCASE$.h&gt;
#include &lt;mechanisms/StateStruc.h&gt;

//========= Hand modified code start section 0 ========

//========= Hand modified code end section 0 ========

// Third Party Includes

//========= Hand modified code start section 1 ========

//========= Hand modified code end section 1 ========

class $MECHANISM_NAME$StateMgr : public StateMgr
//========= Hand modified code start section 2 ========
//========= Hand modified code end section 2 ========
{
    public:
	    /// @enum the various states of the Intake
        enum $MECHANISM_NAME_UPPERCASE$_STATE
        {
            $COMMA_SEPARATED_MECHANISM_STATES$
        };
		
        const std::map&lt;const std::string, $MECHANISM_NAME_UPPERCASE$_STATE&gt; m_$MECHANISM_NAME_LOWERCASE$XmlStringToStateEnumMap
        {   
			$XML_STRING_TO_STATE_ENUM_MAP$
        };
        
		/// @brief  Find or create the state manmanager
		static $MECHANISM_NAME$StateMgr* GetInstance();

        /// @brief  Get the current Parameter parm value for the state of this mechanism
        /// @param PrimitiveParams* currentParams current set of primitive parameters
        /// @returns int state id - -1 indicates that there is not a state to set
        int GetCurrentStateParam
        (
            PrimitiveParams*    currentParams
        ) override;

        void CheckForStateTransition() override;
		    //========= Hand modified code start section 3 ========

    //========= Hand modified code end section 3 ========

    private:
	
        $MECHANISM_NAME$StateMgr();
        ~$MECHANISM_NAME$StateMgr() = default;
           
		    //========= Hand modified code start section 4 ========

    //========= Hand modified code end section 4 ========

        $MECHANISM_NAME$*                                m_$MECHANISM_NAME_LOWERCASE$;

    //========= Hand modified code start section 5 ========
    //========= Hand modified code end section 5 ========

		static $MECHANISM_NAME$StateMgr*	m_instance;

		$STATE_STRUCT$
};
</stateManager_h>

<stateManager_cpp>

#include &lt;map&gt;

// FRC includes

// Team 302 includes
#include &lt;teleopcontrol/TeleopControl.h&gt;
#include &lt;auton/PrimitiveParams.h&gt;
#include &lt;mechanisms/MechanismFactory.h&gt;
#include &lt;mechanisms/base/StateMgr.h&gt;
#include &lt;mechanisms/StateStruc.h&gt;
#include &lt;mechanisms/$MECHANISM_NAME_LOWERCASE$/$MECHANISM_NAME_LOWERCASE$.h&gt;
#include &lt;mechanisms/$MECHANISM_NAME_LOWERCASE$/$MECHANISM_NAME_LOWERCASE$State.h&gt;
#include &lt;mechanisms/$MECHANISM_NAME_LOWERCASE$/$MECHANISM_NAME_LOWERCASE$StateMgr.h&gt;
#include &lt;robotstate/RobotState.h&gt;
#include &lt;robotstate/RobotStateChanges.h&gt;
#include &lt;utils/logging/Logger.h&gt;


// Third Party Includes

//========= Hand modified code start section 0 ========
//========= Hand modified code end section 0 ========

using namespace std;


$MECHANISM_NAME$StateMgr* $MECHANISM_NAME$StateMgr::m_instance = nullptr;
$MECHANISM_NAME$StateMgr* $MECHANISM_NAME$StateMgr::GetInstance()
{
	if ( $MECHANISM_NAME$StateMgr::m_instance == nullptr )
	{
        auto $MECHANISM_NAME_LOWERCASE$Ptr = MechanismFactory::GetMechanismFactory()->Get$MECHANISM_NAME$();
        if ($MECHANISM_NAME_LOWERCASE$Ptr != nullptr)
        {
            $MECHANISM_NAME$StateMgr::m_instance = new $MECHANISM_NAME$StateMgr();
        }
	}
	return $MECHANISM_NAME$StateMgr::m_instance;
    
}


/// @brief    initialize the state manager, parse the configuration file and create the states.
$MECHANISM_NAME$StateMgr::$MECHANISM_NAME$StateMgr() : StateMgr(),
                                     m_$MECHANISM_NAME_LOWERCASE$(MechanismFactory::GetMechanismFactory()-&gt;Get$MECHANISM_NAME$())
									 //========= Hand modified code start section 1 ========
                                     //========= Hand modified code end section 1 ========

{
    map&lt;string, StateStruc&gt; stateMap;
	$STATE_MAP_INITIALIZATION$

    Init(m_$MECHANISM_NAME_LOWERCASE$, stateMap);
    if (m_$MECHANISM_NAME_LOWERCASE$ != nullptr)
    {
        m_$MECHANISM_NAME_LOWERCASE$->AddStateMgr(this);
    }

//========= Hand modified code start section 2 ========
//========= Hand modified code end section 2 ========
}   

/// @brief  Get the current Parameter parm value for the state of this mechanism
/// @param PrimitiveParams* currentParams current set of primitive parameters
/// @returns int state id - -1 indicates that there is not a state to set
int $MECHANISM_NAME$StateMgr::GetCurrentStateParam
(
    PrimitiveParams*    currentParams
) 
{
    // normally get the state from primitive params
    return StateMgr::GetCurrentStateParam(currentParams);
}

/// @brief Check if driver inputs or sensors trigger a state transition
void $MECHANISM_NAME$StateMgr::CheckForStateTransition()
{
		//========= Hand modified code start section 3 ========
	
    	//========= Hand modified code end section 3 ========
}

//========= Hand modified code start section 4 ========
//========= Hand modified code end section 4 ========

</stateManager_cpp>

<StateStruc_h>

#pragma once
#include &lt;string&gt;
       
enum StateType
{
    $STATE_STRUCT$
    //========= Hand modified code start section 0 ========
    //========= Hand modified code end section 0 ========
    MAX_STATE_TYPES
};


struct StateStruc
{
    int         id;
    std::string xmlIdentifier;
    StateType   type;
    bool        isDefault;
};

</StateStruc_h>

</toolConfiguration>